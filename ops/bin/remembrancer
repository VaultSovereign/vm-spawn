#!/usr/bin/env bash
# remembrancer - VaultMesh Covenant Memory CLI Tool
# Purpose: Record deployments, query decisions, generate cryptographic receipts

set -euo pipefail

# Configuration
WORKSPACE_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"
MEMORY_INDEX="$WORKSPACE_ROOT/docs/REMEMBRANCER.md"
RECEIPTS_DIR="$WORKSPACE_ROOT/ops/receipts"
TIMESTAMP="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Display usage
usage() {
  cat <<EOF
${CYAN}üß† The Remembrancer${NC} - VaultMesh Covenant Memory CLI

${YELLOW}USAGE:${NC}
  remembrancer <command> [options]

${YELLOW}COMMANDS:${NC}
  ${GREEN}record${NC}        Record a new memory (deployment, ADR, incident)
  ${GREEN}query${NC}         Query historical decisions and context
  ${GREEN}list${NC}          List memories by type
  ${GREEN}receipt${NC}       Generate cryptographic receipt for a memory
  ${GREEN}verify${NC}        Verify artifact integrity (SHA256)
  ${GREEN}timeline${NC}      Show chronological memory timeline
  ${GREEN}adr${NC}           Architectural Decision Record operations

${YELLOW}v3.0 COVENANT FOUNDATION:${NC}
  ${GREEN}sign${NC}          Sign artifact with GPG (detached signature)
  ${GREEN}timestamp${NC}     Create RFC3161 timestamp for artifact
  ${GREEN}verify-full${NC}   Verify hash + signature + timestamp chain
  ${GREEN}export-proof${NC}  Bundle artifact + signature + timestamp
  ${GREEN}verify-audit${NC}  Verify Merkle root integrity

${YELLOW}EXAMPLES:${NC}
  # Record a deployment
  remembrancer record deploy \\
    --component spawn-elite \\
    --version v2.2 \\
    --sha256 44e8ecd... \\
    --evidence V2.2_PRODUCTION_SUMMARY.md

  # Query a decision
  remembrancer query "why bash scripts?"

  # List all deployments
  remembrancer list deployments

  # Generate receipt
  remembrancer receipt deploy/spawn-elite/v2.2

  # Verify artifact
  remembrancer verify vaultmesh-spawn-elite-v2.2-PRODUCTION.tar.gz

  # Show timeline
  remembrancer timeline --since 2025-10-01

  # Create ADR
  remembrancer adr create "Use PostgreSQL for persistent storage"

  # v3.0: Sign artifact
  remembrancer sign vaultmesh-v3.0.tar.gz --key <your-key-id>

  # v3.0: Timestamp artifact
  remembrancer timestamp vaultmesh-v3.0.tar.gz

  # v3.0: Verify full chain
  remembrancer verify-full vaultmesh-v3.0.tar.gz

  # v3.0: Verify audit log
  remembrancer verify-audit

${YELLOW}OPTIONS:${NC}
  -h, --help       Show this help message
  -v, --version    Show version

${PURPLE}The Remembrancer ensures that knowledge compounds, not entropy.${NC}
EOF
}

# Initialize receipts directory structure
init_receipts() {
  mkdir -p "$RECEIPTS_DIR"/{deploy,adr,incident,discovery}
}

# Record a deployment
record_deploy() {
  local component="$1"
  local version="$2"
  local sha256="$3"
  local evidence="$4"

  local receipt_file="$RECEIPTS_DIR/deploy/${component}-${version}.receipt"
  
  cat > "$receipt_file" <<EOF
---
type: deployment
component: $component
version: $version
timestamp: $TIMESTAMP
evidence:
  artifact: $evidence
  sha256: $sha256
status: active
verified_by: remembrancer-cli
---

This receipt cryptographically attests to the deployment of:

  Component: $component
  Version: $version
  Timestamp: $TIMESTAMP
  SHA256: $sha256

Verification:
  shasum -a 256 $evidence

This memory is recorded in the VaultMesh Covenant Index.
EOF

  echo -e "${GREEN}‚úÖ Deployment recorded${NC}"
  echo -e "   Receipt: ${CYAN}$receipt_file${NC}"
  echo -e "   SHA256: ${YELLOW}$sha256${NC}"
}

# Query memory index
query_memory() {
  local query="$1"
  
  if [[ ! -f "$MEMORY_INDEX" ]]; then
    echo -e "${RED}‚ùå Memory index not found: $MEMORY_INDEX${NC}"
    exit 1
  fi

  echo -e "${CYAN}üîç Searching memory for: \"$query\"${NC}"
  echo ""
  
  # Simple grep-based search (can be enhanced with semantic search)
  grep -i -C 5 "$query" "$MEMORY_INDEX" || {
    echo -e "${YELLOW}‚ö†Ô∏è  No memories found matching \"$query\"${NC}"
    exit 0
  }
}

# List memories by type
list_memories() {
  local type="${1:-all}"
  
  if [[ ! -f "$MEMORY_INDEX" ]]; then
    echo -e "${RED}‚ùå Memory index not found: $MEMORY_INDEX${NC}"
    exit 1
  fi

  echo -e "${CYAN}üìã Listing memories: $type${NC}"
  echo ""

  case "$type" in
    deployments)
      grep -E "^###.*‚Äî.*Released$" "$MEMORY_INDEX" || echo "No deployments found"
      ;;
    adrs|decisions)
      grep -E "^\*\*ADR-[0-9]+:" "$MEMORY_INDEX" || echo "No ADRs found"
      ;;
    all)
      grep -E "^(###|##) " "$MEMORY_INDEX"
      ;;
    *)
      echo -e "${RED}‚ùå Unknown type: $type${NC}"
      echo "   Valid types: deployments, adrs, decisions, all"
      exit 1
      ;;
  esac
}

# Generate cryptographic receipt
generate_receipt() {
  local memory_path="$1"
  local receipt_file="$RECEIPTS_DIR/${memory_path}.receipt"

  if [[ -f "$receipt_file" ]]; then
    echo -e "${GREEN}üìú Receipt found${NC}"
    cat "$receipt_file"
  else
    echo -e "${YELLOW}‚ö†Ô∏è  Receipt not found: $receipt_file${NC}"
    echo "   Available receipts:"
    find "$RECEIPTS_DIR" -name "*.receipt" -type f | sed 's|^|   - |'
  fi
}

# Verify artifact integrity
verify_artifact() {
  local artifact="$1"
  
  if [[ ! -f "$artifact" ]]; then
    echo -e "${RED}‚ùå Artifact not found: $artifact${NC}"
    exit 1
  fi

  echo -e "${CYAN}üîê Verifying artifact integrity...${NC}"
  
  # Compute SHA256
  if command -v sha256sum &> /dev/null; then
    local computed_hash=$(sha256sum "$artifact" | awk '{print $1}')
  elif command -v shasum &> /dev/null; then
    local computed_hash=$(shasum -a 256 "$artifact" | awk '{print $1}')
  else
    echo -e "${RED}‚ùå No SHA256 tool available (sha256sum or shasum)${NC}"
    exit 1
  fi

  echo -e "${GREEN}‚úÖ SHA256 computed${NC}"
  echo -e "   File: ${CYAN}$artifact${NC}"
  echo -e "   Hash: ${YELLOW}$computed_hash${NC}"
  echo ""
  echo "To verify against recorded memory, check:"
  echo "  grep -i \"$computed_hash\" $MEMORY_INDEX"
}

# Show timeline
show_timeline() {
  local since="${1:-}"
  
  if [[ ! -f "$MEMORY_INDEX" ]]; then
    echo -e "${RED}‚ùå Memory index not found: $MEMORY_INDEX${NC}"
    exit 1
  fi

  echo -e "${CYAN}üìÖ Memory Timeline${NC}"
  echo ""

  if [[ -n "$since" ]]; then
    echo "Showing entries since: $since"
    echo ""
    # Filter by date (simple approach)
    grep -E "^### [0-9]{4}-[0-9]{2}-[0-9]{2}" "$MEMORY_INDEX" | while read -r line; do
      local entry_date=$(echo "$line" | grep -oE "[0-9]{4}-[0-9]{2}-[0-9]{2}")
      if [[ "$entry_date" > "$since" ]] || [[ "$entry_date" == "$since" ]]; then
        echo "$line"
      fi
    done
  else
    grep -E "^### [0-9]{4}-[0-9]{2}-[0-9]{2}" "$MEMORY_INDEX"
  fi
}

# Create ADR
create_adr() {
  local title="$1"
  local adr_num=$(grep -cE "^\*\*ADR-[0-9]+:" "$MEMORY_INDEX" 2>/dev/null || echo 0)
  ((adr_num++))
  
  local adr_id=$(printf "ADR-%03d" $adr_num)
  
  echo -e "${CYAN}üìù Creating $adr_id: $title${NC}"
  echo ""
  echo "Template (add to REMEMBRANCER.md):"
  echo ""
  cat <<EOF
**$adr_id: $title**
- **Decision:** [State the decision]
- **Rationale:** [Explain why this decision was made]
- **Trade-offs:** [What are the costs/benefits?]
- **Status:** Proposed
- **Date:** $TIMESTAMP
EOF
  echo ""
  echo -e "${YELLOW}‚ö†Ô∏è  Manual step: Add the above to $MEMORY_INDEX${NC}"
}

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# v3.0 Covenant Foundation hooks
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

REM_DB="${REM_DB:-$WORKSPACE_ROOT/ops/data/remembrancer.db}"
REM_CERTS_DIR="${REM_CERTS_DIR:-$WORKSPACE_ROOT/ops/certs}"
FREETSA_CA="${FREETSA_CA:-${REM_CERTS_DIR}/freetsa-ca.pem}"
DEFAULT_TSA_URL="${DEFAULT_TSA_URL:-https://freetsa.org/tsr}"

# --- deps & utilities ---------------------------------------------------------
sha256_of() {
  if command -v sha256sum >/dev/null 2>&1; then sha256sum "$1" | awk '{print $1}'
  elif command -v shasum >/dev/null 2>&1; then shasum -a 256 "$1" | awk '{print $1}'
  else echo "No sha256 tool found" >&2; return 1; fi
}

need() { command -v "$1" >/dev/null 2>&1 || { echo "Missing dependency: $1" >&2; exit 2; }; }

ensure_db() {
  mkdir -p "$(dirname "$REM_DB")"
  if [[ ! -f "$REM_DB" ]]; then
    need sqlite3
    sqlite3 "$REM_DB" <<'SQL'
CREATE TABLE IF NOT EXISTS memories (
  id TEXT PRIMARY KEY,
  timestamp TEXT NOT NULL,
  type TEXT NOT NULL,
  component TEXT,
  version TEXT,
  hash TEXT,
  sig TEXT,
  data JSON,
  merkle_root TEXT
);
CREATE INDEX IF NOT EXISTS idx_timestamp ON memories(timestamp);
CREATE INDEX IF NOT EXISTS idx_component ON memories(component);
CREATE INDEX IF NOT EXISTS idx_type ON memories(type);
SQL
  fi
}

insert_memory() {
  # args: id, ts, type, component, version, hash, sig, data_json, merkle_root
  ensure_db
  sqlite3 "$REM_DB" \
    "INSERT OR REPLACE INTO memories (id,timestamp,type,component,version,hash,sig,data,merkle_root)
     VALUES (?,?,?,?,?,?,?,?,?);" \
     "$1" "$2" "$3" "$4" "$5" "$6" "$7" "$8" "$9"
}

# --- signing ------------------------------------------------------------------
sign_artifact() {
  local artifact="$1"; local key_id="$2"
  need gpg
  [[ -f "$artifact" ]] || { echo "Error: Artifact not found: $artifact" >&2; exit 1; }
  local asc="${artifact}.asc"

  # Detached, armored signature with explicit output (non-interactive safe)
  gpg --batch --yes --armor --detach-sign \
      --local-user "$key_id" \
      --output "$asc" "$artifact"

  local sig_sha256; sig_sha256="$(sha256_of "$asc")"
  echo "‚úÖ Signature created: $asc (sha256=$sig_sha256)"

  # Optional index into audit DB as a 'signature' memory
  local now; now="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
  insert_memory \
    "sig:${artifact}" "$now" "signature" "remembrancer" "v3.0" \
    "$(sha256_of "$artifact")" "$sig_sha256" \
    "{\"artifact\":\"$artifact\",\"sig\":\"$asc\",\"keyid\":\"$key_id\"}" \
    "" 2>/dev/null || true
}

verify_signature() {
  local artifact="$1"
  local asc="${artifact}.asc"
  need gpg
  [[ -f "$artifact" && -f "$asc" ]] || { echo "Missing $artifact or $asc" >&2; exit 1; }
  if gpg --verify "$asc" "$artifact" 2>&1; then
    echo "‚úÖ GPG signature valid for $artifact"
  else
    echo "‚ùå GPG verification failed for $artifact" >&2; exit 1
  fi
}

# --- timestamping (RFC3161) ---------------------------------------------------
timestamp_artifact() {
  local artifact="$1"; local tsa="${2:-$DEFAULT_TSA_URL}"
  need openssl; need curl
  [[ -f "$artifact" ]] || { echo "Error: Artifact not found: $artifact" >&2; exit 1; }

  local tsq="${artifact}.tsq"; local tsr="${artifact}.tsr"
  # Include -cert so TSA cert is returned in the response (helps verify)
  openssl ts -query -data "$artifact" -sha256 -cert -out "$tsq"
  curl -sS -H "Content-Type: application/timestamp-query" --data-binary "@${tsq}" "$tsa" > "$tsr"
  echo "‚úÖ Timestamp token received: $tsr"

  # Verify if CA is present; FreeTSA uses a self-signed CA you must provide.
  if [[ -f "$FREETSA_CA" ]]; then
    if openssl ts -verify -data "$artifact" -in "$tsr" -CAfile "$FREETSA_CA" >/dev/null 2>&1; then
      echo "‚úÖ Timestamp verified against TSA CA ($FREETSA_CA)"
    else
      echo "‚ö†Ô∏è  Timestamp present but could not be verified with provided CA ($FREETSA_CA)" >&2
    fi
  else
    echo "‚ÑπÔ∏è  Timestamp created; provide TSA CA at ${REM_CERTS_DIR}/freetsa-ca.pem to verify."
  fi

  # Optional index into audit DB
  local now; now="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
  insert_memory \
    "ts:${artifact}" "$now" "timestamp" "remembrancer" "v3.0" \
    "$(sha256_of "$artifact")" "" \
    "{\"artifact\":\"$artifact\",\"tsr\":\"${artifact}.tsr\",\"tsa\":\"$tsa\"}" \
    "" 2>/dev/null || true
}

# --- export proof bundle ------------------------------------------------------
export_proof() {
  local artifact="$1"
  local asc="${artifact}.asc"; local tsr="${artifact}.tsr"
  [[ -f "$artifact" ]] || { echo "Missing $artifact" >&2; exit 1; }
  [[ -f "$asc" ]] || echo "‚ö†Ô∏è  No signature found at $asc"
  [[ -f "$tsr" ]] || echo "‚ö†Ô∏è  No timestamp found at $tsr"
  local out="${artifact%.tar.gz}.proof.tgz"
  tar -czf "$out" "$artifact" $([[ -f "$asc" ]] && echo "$asc") $([[ -f "$tsr" ]] && echo "$tsr")
  echo "‚úÖ Proof bundle: $out"
}

# --- verify-full: hash + signature + timestamp --------------------------------
verify_full() {
  local artifact="$1"
  [[ -f "$artifact" ]] || { echo "Missing $artifact" >&2; exit 1; }
  echo "‚Ä¢ sha256: $(sha256_of "$artifact")"

  # 1) GPG signature (if exists)
  if [[ -f "${artifact}.asc" ]]; then
    verify_signature "$artifact"
  else
    echo "‚ÑπÔ∏è  No .asc signature present ‚Äî skipping"
  fi

  # 2) RFC3161 timestamp (if exists)
  if [[ -f "${artifact}.tsr" ]]; then
    if [[ -f "$FREETSA_CA" ]]; then
      if openssl ts -verify -data "$artifact" -in "${artifact}.tsr" -CAfile "$FREETSA_CA" >/dev/null 2>&1; then
        echo "‚úÖ RFC3161 timestamp valid"
      else
        echo "‚ùå RFC3161 timestamp verification failed" >&2; exit 1
      fi
    else
      echo "‚ÑπÔ∏è  TSA CA not installed; timestamp present but not verified"
    fi
  else
    echo "‚ÑπÔ∏è  No .tsr timestamp present ‚Äî skipping"
  fi

  echo "‚úÖ verify-full PASSED for $artifact"
}

# --- audit: Merkle root computation & verification ----------------------------
verify_audit() {
  need python3
  
  # Compute Merkle root from database
  python3 "$WORKSPACE_ROOT/ops/lib/merkle.py" --compute --from-sqlite "$REM_DB" > .merkle_root.tmp 2>/dev/null || true
  local computed_root; computed_root="$(cat .merkle_root.tmp 2>/dev/null || true)"
  rm -f .merkle_root.tmp
  
  # Extract root from "Merkle Root: <hash>" or "**Merkle Root:** <hash>" format
  local published_root; published_root="$(grep -m1 -i "Merkle Root" "$MEMORY_INDEX" 2>/dev/null | grep -oE '[0-9a-f]{64}' 2>/dev/null | head -1 || true)"

  # No published root = dev mode, show computed root
  if [[ -z "$published_root" ]]; then
    echo "‚ÑπÔ∏è  No published Merkle Root found in docs/REMEMBRANCER.md"
    if [[ -n "$computed_root" ]]; then
      echo "‚Üí Computed Merkle Root: $computed_root"
    fi
    return 0
  fi

  # Both roots present = verify integrity
  if [[ "$computed_root" == "$published_root" ]]; then
    echo "‚úÖ Audit log integrity verified (root=$computed_root)"
    return 0
  else
    echo "‚ùå AUDIT LOG TAMPERED ‚Äî computed=$computed_root published=$published_root" >&2
    return 1
  fi
}

# --- receipts: add v3.0 fields ------------------------------------------------
record_receipt_v3() {
  # args: component version artifact keyid tsa_url
  local component="$1" version="$2" artifact="$3" key="$4" tsa="${5:-$DEFAULT_TSA_URL}"
  local ts; ts="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
  local sha; sha="$(sha256_of "$artifact")"
  local asc="${artifact}.asc"; local sigsha=""; [[ -f "$asc" ]] && sigsha="$(sha256_of "$asc")"
  local tsr="${artifact}.tsr"

  cat <<YAML
---
schema_version: "3.0"
type: deployment
component: ${component}
version: ${version}
timestamp: ${ts}
evidence:
  artifact: ${artifact}
  sha256: ${sha}
signatures:
  - type: gpg
    keyid: ${key}
    sig_file: ${asc}
    sig_sha256: ${sigsha}
timestamps:
  - type: rfc3161
    tsa: ${tsa}
    token_file: ${tsr}
status: active
---
YAML
}

# Main command dispatcher
main() {
  if [[ $# -eq 0 ]]; then
    usage
    exit 0
  fi

  local command="$1"
  shift

  case "$command" in
    record)
      local subcommand="${1:-}"
      shift || true
      case "$subcommand" in
        deploy)
          if [[ $# -lt 4 ]]; then
            echo "Usage: remembrancer record deploy --component <name> --version <ver> --sha256 <hash> --evidence <file>"
            exit 1
          fi
          # Parse flags (simplified)
          local component="" version="" sha256="" evidence=""
          while [[ $# -gt 0 ]]; do
            case "$1" in
              --component) component="$2"; shift 2;;
              --version) version="$2"; shift 2;;
              --sha256) sha256="$2"; shift 2;;
              --evidence) evidence="$2"; shift 2;;
              *) shift;;
            esac
          done
          init_receipts
          record_deploy "$component" "$version" "$sha256" "$evidence"
          ;;
        *)
          echo "Usage: remembrancer record [deploy]"
          exit 1
          ;;
      esac
      ;;
    query)
      query_memory "$*"
      ;;
    list)
      list_memories "${1:-all}"
      ;;
    receipt)
      generate_receipt "${1:-}"
      ;;
    verify)
      verify_artifact "${1:-}"
      ;;
    timeline)
      local since=""
      if [[ "${1:-}" == "--since" ]]; then
        since="${2:-}"
      fi
      show_timeline "$since"
      ;;
    adr)
      local subcommand="${1:-}"
      shift || true
      case "$subcommand" in
        create)
          create_adr "$*"
          ;;
        *)
          echo "Usage: remembrancer adr [create]"
          exit 1
          ;;
      esac
      ;;
    sign)
      # remembrancer sign <artifact> --key <id>
      local artifact="${1:-}"
      shift || true
      local key_id=""
      if [[ "${1:-}" == "--key" ]]; then
        key_id="${2:-}"
      fi
      if [[ -z "$artifact" || -z "$key_id" ]]; then
        echo "Usage: remembrancer sign <artifact> --key <gpg-key-id>"
        exit 1
      fi
      sign_artifact "$artifact" "$key_id"
      ;;
    timestamp)
      # remembrancer timestamp <artifact> [tsa-url]
      local artifact="${1:-}"
      local tsa="${2:-$DEFAULT_TSA_URL}"
      if [[ -z "$artifact" ]]; then
        echo "Usage: remembrancer timestamp <artifact> [tsa-url]"
        exit 1
      fi
      timestamp_artifact "$artifact" "$tsa"
      ;;
    verify-full)
      # remembrancer verify-full <artifact>
      local artifact="${1:-}"
      if [[ -z "$artifact" ]]; then
        echo "Usage: remembrancer verify-full <artifact>"
        exit 1
      fi
      verify_full "$artifact"
      ;;
    export-proof)
      # remembrancer export-proof <artifact>
      local artifact="${1:-}"
      if [[ -z "$artifact" ]]; then
        echo "Usage: remembrancer export-proof <artifact>"
        exit 1
      fi
      export_proof "$artifact"
      ;;
    verify-audit)
      # remembrancer verify-audit
      verify_audit
      ;;
    record-receipt-v3)
      # remembrancer record-receipt-v3 <component> <version> <artifact> <keyid> [tsa-url]
      if [[ $# -lt 4 ]]; then
        echo "Usage: remembrancer record-receipt-v3 <component> <version> <artifact> <keyid> [tsa-url]"
        exit 1
      fi
      record_receipt_v3 "$@"
      ;;
    federation)
      local sub="${1:-}"
      shift || true
      case "$sub" in
        init)
          # Create example config; operator adjusts node_id
          mkdir -p "$WORKSPACE_ROOT/ops/data"
          if [[ ! -f "$WORKSPACE_ROOT/ops/data/federation.yaml" ]]; then
            cp "$WORKSPACE_ROOT/ops/data/federation.yaml.example" "$WORKSPACE_ROOT/ops/data/federation.yaml" 2>/dev/null || true
          fi
          echo "‚úÖ federation.yaml created at ops/data/federation.yaml (edit node_id)"
          ;;
        join)
          # Append peer to federation.yaml
          local peer_url="" anchor=""
          while [[ $# -gt 0 ]]; do
            case "$1" in
              --peer) peer_url="$2"; shift 2;;
              --trust-anchor) anchor="$2"; shift 2;;
              *) break;;
            esac
          done
          if [[ ! -f "$WORKSPACE_ROOT/ops/data/federation.yaml" ]]; then
            echo "‚ùå Missing ops/data/federation.yaml. Run 'remembrancer federation init'." >&2
            exit 1
          fi
          python3 - "$peer_url" "$anchor" <<'PY'
import sys, yaml
peer, anchor = sys.argv[1], sys.argv[2]
doc = yaml.safe_load(open("ops/data/federation.yaml","r",encoding="utf-8"))
doc.setdefault("peers", []).append({"node_id": "UNKNOWN", "mcp_url": peer, "trust_anchor": anchor})
open("ops/data/federation.yaml","w",encoding="utf-8").write(yaml.safe_dump(doc, sort_keys=False))
print("‚úÖ Peer appended:", peer)
PY
          ;;
        status)
          if [[ -f "$WORKSPACE_ROOT/ops/data/federation.yaml" ]]; then
            cat "$WORKSPACE_ROOT/ops/data/federation.yaml"
          else
            echo "No federation.yaml present."
          fi
          ;;
        *)
          echo "Usage: remembrancer federation {init|join --peer <url> --trust-anchor <pubkey>|status}"
          exit 1
          ;;
      esac
      ;;
    -h|--help)
      usage
      ;;
    -v|--version)
      echo "remembrancer v4.0.0 (VaultMesh Federated C3L Kickoff)"
      ;;
    *)
      echo -e "${RED}‚ùå Unknown command: $command${NC}"
      echo ""
      usage
      exit 1
      ;;
  esac
}

main "$@"

